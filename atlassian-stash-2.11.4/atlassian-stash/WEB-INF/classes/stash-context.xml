<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:cache="http://www.springframework.org/schema/cache"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:plugin="http://atlassian.com/schema/spring/plugin"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://atlassian.com/schema/spring/plugin
                           http://atlassian.com/schema/spring/plugin.xsd
                           http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/cache
                           http://www.springframework.org/schema/cache/spring-cache.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/tx
                           http://www.springframework.org/schema/tx/spring-tx.xsd
                           http://www.springframework.org/schema/util
                           http://www.springframework.org/schema/util/spring-util.xsd">

    <!-- Warning: This must _always_ be the first import. Do not add bean definitions above this line, and do not
                  import other configuration files before it. -->
    <import resource="critical-context.xml"/>

    <!-- Spring application contexts are hierarchical and have some restrictions on the visibility of beans between
         child contexts. Specifically, the tx:annotation-driven and context-annotation-config need to be defined in
         the parent application context to be visible to all child contexts. -->
    <import resource="crowd-spi-context.xml"/>
    <import resource="security-context.xml"/>

    <!--
    This is the current set of advisors ordered from outer most advise to the inner. The numbers here should reflect
    the number specified in the order attribute
    0 - Exception rewrite
    1 - Transaction
    2 - Authorization
    3 - Caching
    4 - Throttling
    5 - Profiling
    -->

    <aop:config>
        <aop:pointcut id="pluginStateStorePointcut" expression="execution(* com.atlassian.stash.internal.plugin.DefaultPluginPersistentStateStore.*(..))"/>
        <aop:advisor advice-ref="defaultTxAdvice" pointcut-ref="pluginStateStorePointcut" order="1"/>
    </aop:config>
    <aop:config>
        <aop:pointcut id="exceptionMappingPointcut" expression="@within(org.springframework.stereotype.Service) "/>
        <aop:advisor advice-ref="exceptionRewriteAdvice" pointcut-ref="exceptionMappingPointcut" order="0"/>
    </aop:config>
    <aop:config>
        <aop:aspect ref="throttledAspect" order="4">
            <aop:around method="throttle" arg-names="annotation" pointcut="@annotation(annotation) or @within(annotation)"/>
        </aop:aspect>
    </aop:config>
    <!--
     This method is a stepping stone to removal of deprecated methods and should be
     removed in 1.3+. It allows us to have deprecated methods delegating to
     their replacement methods while preserving Spring AOP behaviour and avoiding
     duplication of AOP-related annotations on the deprecated methods.
     -->
    <aop:aspectj-autoproxy expose-proxy="true"/>

    <context:annotation-config/>
    <context:component-scan base-package="com.atlassian.stash">
        <!-- Don't scan the Spring MVC controllers as they're loaded through a separate child application context -->
        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>

    <tx:advice id="defaultTxAdvice">
        <tx:attributes>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="find*" read-only="true"/>
            <tx:method name="search*" read-only="true"/>
            <tx:method name="load*" read-only="true"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>
    <tx:annotation-driven order="1"/>

    <!-- Cache manager -->
    <bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager">
        <property name="cacheManager" ref="ehcache"/>
    </bean>
    <cache:annotation-driven order="3"/>

    <!-- Ehcache library setup -->
    <bean id="ehcache" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean">
        <property name="configLocation" value="classpath:/ehcache.xml"/>
        <property name="shared" value="true"/>
    </bean>

    <!-- SAL services provided by core -->
    <bean id="threadLocalDelegateExecutorFactory"
          class="com.atlassian.sal.core.executor.DefaultThreadLocalDelegateExecutorFactory" plugin:available="true">
        <plugin:interface>com.atlassian.sal.api.executor.ThreadLocalDelegateExecutorFactory</plugin:interface>
        <constructor-arg ref="threadLocalContextManager"/>
    </bean>

    <!-- Event framework -->
    <bean id="eventDispatcher" class="com.atlassian.event.internal.AsynchronousAbleEventDispatcher">
        <constructor-arg ref="eventExecutorFactory"/>
    </bean>

    <bean id="eventListenerHandlersConfiguration"
          class="com.atlassian.stash.internal.plugin.ListenerHandlerConfigurationFactoryBean"
          plugin:available="true">
        <constructor-arg>
            <list value-type="com.atlassian.event.spi.ListenerHandler">
                <!-- Listens based on the default "EventListener" annotation -->
                <bean class="com.atlassian.event.internal.AnnotatedMethodsListenerHandler"/>
                <!-- Listens based on the "PluginEventListener" annotation. This is required in order for the plugin
                     framework to function correctly when using the EventPublisher created from this configuration. -->
                <bean class="com.atlassian.event.internal.AnnotatedMethodsListenerHandler">
                    <constructor-arg value="com.atlassian.plugin.event.PluginEventListener"/>
                </bean>
            </list>
        </constructor-arg>
    </bean>

    <bean id="eventPublisher" class="com.atlassian.stash.internal.event.TransactionAwareEventPublisher" plugin:available="true">
        <constructor-arg index="0">
            <bean class="com.atlassian.stash.internal.event.LockFreeEventPublisher">
                <constructor-arg index="0" ref="eventDispatcher"/>
                <constructor-arg index="1" ref="eventListenerHandlersConfiguration"/>
                <constructor-arg index="2">
                    <bean class="com.atlassian.stash.internal.event.AsyncBatchingInvokersTransformer"/>
                </constructor-arg>
            </bean>
        </constructor-arg>
    </bean>
    <bean id="eventListenerRegistrar" class="com.atlassian.stash.internal.event.EventListenerRegistrar">
        <constructor-arg index="0"><idref bean="eventPublisher"/></constructor-arg>
        <constructor-arg index="1" ref="eventListenerHandlersConfiguration"/>
    </bean>
    
    <bean id="johnsonEventListener" class="com.atlassian.johnson.event.JohnsonEventListener">
        <constructor-arg ref="servletContext"/>
    </bean>

    <!-- Licensing -->
    <bean id="licenseDecoder" class="com.atlassian.extras.decoder.v2.Version2LicenseDecoder"/>
    <bean id="licenseFactory" class="com.atlassian.extras.core.DefaultAtlassianLicenseFactory">
        <constructor-arg>
            <map key-type="com.atlassian.extras.api.Product"
                 value-type="com.atlassian.extras.core.ProductLicenseFactory">
                <entry key="#{T(com.atlassian.extras.api.Product).STASH}">
                    <bean class="com.atlassian.extras.core.stash.StashProductLicenseFactory"/>
                </entry>
            </map>
        </constructor-arg>
    </bean>
    <bean id="licenseManager" class="com.atlassian.extras.core.DefaultLicenseManager">
        <constructor-arg index="0" ref="licenseDecoder"/>
        <constructor-arg index="1" ref="licenseFactory"/>
    </bean>
    <bean id="sidManager" class="com.atlassian.license.DefaultSIDManager"/>

    <!-- Plugin Framework -->
    <bean id="osgiBundleFactory" class="com.atlassian.plugin.osgi.factory.OsgiBundleFactory">
        <constructor-arg index="0" ref="osgiContainerManager"/>
        <constructor-arg index="1" ref="pluginEventManager"/>
    </bean>
    <bean id="osgiContainerManager" class="com.atlassian.plugin.osgi.container.felix.FelixOsgiContainerManager">
        <constructor-arg index="0" value="#{pluginConfiguration.osgiPersistentCache}"/>
        <constructor-arg index="1" value="#{pluginConfiguration.packageScannerConfiguration}"/>
        <constructor-arg index="2" value="#{pluginConfiguration.hostComponentProvider}"/>
        <constructor-arg index="3" ref="pluginEventManager"/>
    </bean>
    <bean id="osgiPluginFactory" class="com.atlassian.plugin.osgi.factory.OsgiPluginFactory">
        <constructor-arg index="0" value="#{pluginConfiguration.pluginDescriptorFilename}"/>
        <constructor-arg index="1">
            <util:set>
                  <value>#{pluginConfiguration.application}</value>
            </util:set>
        </constructor-arg>
        <constructor-arg index="2" value="#{pluginConfiguration.osgiPersistentCache}"/>
        <constructor-arg index="3" ref="osgiContainerManager"/>
        <constructor-arg index="4" ref="pluginEventManager"/>
    </bean>
    <bean id="pluginAccessor" class="com.atlassian.plugin.manager.EnabledModuleCachingPluginAccessor">
        <constructor-arg index="0" ref="pluginManager"/>
        <constructor-arg index="1" ref="pluginEventManager"/>
    </bean>
    <bean id="pluginConfiguration" class="com.atlassian.stash.internal.plugin.PluginConfigurationFactoryBean">
        <constructor-arg index="0" ref="applicationSettings"/>
        <constructor-arg index="1" ref="application"/>
        <constructor-arg index="2" ref="hostComponentProvider"/>
        <constructor-arg index="3" ref="stashModuleDescriptorFactory"/>
        <constructor-arg index="4" ref="stashPackageScannerConfiguration"/>
        <constructor-arg index="5" ref="pluginPersistentStateStore"/>
        <constructor-arg index="6" value="${bundled.plugins.file}"/>
    </bean>
    <util:list id="pluginFactories" value-type="com.atlassian.plugin.factories.PluginFactory">
        <ref bean="osgiPluginFactory"/>
        <ref bean="osgiBundleFactory"/>
        <ref bean="remotablePluginFactory"/>
        <bean class="com.atlassian.plugin.factories.LegacyDynamicPluginFactory">
            <constructor-arg value="#{pluginConfiguration.pluginDescriptorFilename}"/>
        </bean>
    </util:list>
    <util:list id="pluginLoaders" value-type="com.atlassian.plugin.loaders.PluginLoader">
        <bean class="com.atlassian.plugin.loaders.ClassPathPluginLoader">
            <constructor-arg value="stash-plugin.xml"/>
        </bean>
        <bean class="com.atlassian.stash.internal.plugin.ScanningClassPathPluginLoader">
            <constructor-arg value="stash-plugins"/>
        </bean>
        <bean class="com.atlassian.plugin.loaders.BundledPluginLoader">
            <constructor-arg index="0" value="#{pluginConfiguration.bundledPluginUrl}"/>
            <constructor-arg index="1" value="#{pluginConfiguration.bundledPluginCacheDirectory}"/>
            <constructor-arg index="2" ref="pluginFactories"/>
            <constructor-arg index="3" ref="pluginEventManager"/>
        </bean>
        <bean class="com.atlassian.plugin.loaders.DirectoryPluginLoader">
            <constructor-arg index="0" value="#{pluginConfiguration.pluginDirectory}"/>
            <constructor-arg index="1" ref="pluginFactories"/>
            <constructor-arg index="2" ref="pluginEventManager"/>
        </bean>
    </util:list>
    <bean id="pluginEventManager" class="com.atlassian.plugin.event.impl.DefaultPluginEventManager">
        <constructor-arg ref="eventPublisher"/>
    </bean>
    <bean id="pluginManager" class="com.atlassian.plugin.manager.DefaultPluginManager" plugin:available="true">
        <constructor-arg index="0" value="#{pluginConfiguration.pluginStateStore}"/>
        <constructor-arg index="1" ref="pluginLoaders"/>
        <constructor-arg index="2" value="#{pluginConfiguration.moduleDescriptorFactory}"/>
        <constructor-arg index="3" ref="pluginEventManager"/>
        <property name="pluginInstaller">
            <bean class="com.atlassian.plugin.repositories.FilePluginInstaller">
                <constructor-arg value="#{pluginConfiguration.pluginDirectory}"/>
            </bean>
        </property>
        <plugin:interface>com.atlassian.plugin.PluginController</plugin:interface>
    </bean>
    <bean id="pluginModuleFactory" class="com.atlassian.plugin.module.PrefixDelegatingModuleFactory" plugin:available="true">
        <constructor-arg>
            <set value-type="com.atlassian.plugin.module.PrefixModuleFactory">
                <bean class="com.atlassian.plugin.osgi.module.BeanPrefixModuleFactory"/>
                <bean class="com.atlassian.plugin.module.ClassPrefixModuleFactory">
                    <constructor-arg ref="hostContainer"/>
                </bean>
            </set>
        </constructor-arg>
        <plugin:interface>com.atlassian.plugin.module.ModuleFactory</plugin:interface>
    </bean>
    <bean id="pluginPersistentStateStore" class="com.atlassian.stash.internal.plugin.CachingPluginPersistentStateStore">
        <constructor-arg>
            <bean class="com.atlassian.stash.internal.plugin.DefaultPluginPersistentStateStore">
                <constructor-arg type="com.atlassian.stash.internal.plugin.PluginStateDao" ref="pluginStateDao"/>
            </bean>
        </constructor-arg>
    </bean>
    <bean id="pluginResourceDownload" class="com.atlassian.plugin.webresource.servlet.PluginResourceDownload">
        <constructor-arg index="0" ref="pluginResourceLocator"/>
        <constructor-arg index="1" ref="contentTypeResolver"/>
        <constructor-arg index="2" value="UTF-8"/>
    </bean>
    <bean id="pluginResourceLocator" class="com.atlassian.plugin.webresource.PluginResourceLocatorImpl" plugin:available="true">
        <constructor-arg index="0" ref="webResourceIntegration"/>
        <constructor-arg index="1" ref="servletContextFactory"/>
        <constructor-arg index="2" ref="webResourceUrlProvider"/>
        <constructor-arg index="3" ref="resourceBatchingConfiguration"/>
        <constructor-arg index="4" ref="pluginEventManager"/>
        <plugin:interface>com.atlassian.plugin.webresource.PluginResourceLocator</plugin:interface>
    </bean>
    <bean id="remotablePluginFactory" class="com.atlassian.plugin.osgi.factory.RemotablePluginFactory">
        <constructor-arg index="0" value="#{pluginConfiguration.pluginDescriptorFilename}"/>
        <constructor-arg index="1" ref="application"/>
        <constructor-arg index="2" ref="osgiContainerManager"/>
        <constructor-arg index="3" ref="pluginEventManager"/>
    </bean>

    <bean id="resourceResolver" class="com.atlassian.plugin.webresource.DefaultResourceDependencyResolver" plugin:available="true">
        <constructor-arg index="0" ref="webResourceIntegration"/>
        <constructor-arg index="1" ref="resourceBatchingConfiguration"/>
        <plugin:interface>com.atlassian.plugin.webresource.ResourceDependencyResolver</plugin:interface>
    </bean>

    <bean id="scheduler" class="org.springframework.scheduling.quartz.SchedulerFactoryBean" plugin:available="true">
        <plugin:interface>org.quartz.Scheduler</plugin:interface>
        <property name="triggers">
            <list>
                <bean class="org.springframework.scheduling.quartz.SimpleTriggerBean">
                    <property name="jobDetail">
                        <bean class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
                            <property name="concurrent" value="false"/>
                            <property name="targetBeanName" value="avatarRepository"/>
                            <property name="targetMethod" value="cleanupTemporary"/>
                        </bean>
                    </property>
                    <property name="repeatInterval" value="${avatar.temporary.cleanup.interval}"/>
                    <property name="startDelay" value="${avatar.temporary.cleanup.interval}"/>
                </bean>
            </list>
        </property>
        <property name="schedulerContextAsMap">
            <map>
            </map>
        </property>
        <property name="autoStartup" value="true"/>
    </bean>

    <bean id="servletModuleManager" class="com.atlassian.plugin.servlet.DefaultServletModuleManager" plugin:available="true">
        <constructor-arg index="0" ref="servletContext"/>
        <constructor-arg index="1" ref="pluginEventManager"/>
        <plugin:interface>com.atlassian.plugin.servlet.ServletModuleManager</plugin:interface>
    </bean>

    <bean id="webInterfaceManager" class="com.atlassian.plugin.web.DefaultWebInterfaceManager" plugin:available="true">
        <constructor-arg index="0" ref="pluginAccessor"/>
        <constructor-arg index="1" ref="webFragmentHelper"/>
        <plugin:interface>com.atlassian.plugin.web.WebInterfaceManager</plugin:interface>
    </bean>

    <bean id="webResourceBatchingStateCounter" class="com.atlassian.plugin.webresource.WebResourceBatchingStateCounterImpl" plugin:available="true">
        <constructor-arg ref="pluginEventManager"/>
        <plugin:interface>com.atlassian.plugin.webresource.WebResourceBatchingStateCounter</plugin:interface>
    </bean>
    <bean id="webResourceAssemblerFactory" class="com.atlassian.plugin.webresource.assembler.DefaultWebResourceAssemblerFactory" plugin:available="true">
        <constructor-arg index="0" ref="resourceBatchingConfiguration"/>
        <constructor-arg index="1" ref="webResourceIntegration"/>
        <constructor-arg index="2" ref="webResourceUrlProvider"/>
        <constructor-arg index="3" ref="pluginResourceLocator"/>
        <plugin:interface>com.atlassian.webresource.api.assembler.WebResourceAssemblerFactory</plugin:interface>
    </bean>
    <bean id="pageBuilderService" class="com.atlassian.plugin.webresource.assembler.DefaultPageBuilderService" plugin:available="true">
        <constructor-arg index="0" ref="webResourceIntegration"/>
        <constructor-arg index="1" ref="webResourceAssemblerFactory"/>
        <plugin:interface>com.atlassian.webresource.api.assembler.PageBuilderService</plugin:interface>
    </bean>

    <bean id="webResourceManager" class="com.atlassian.plugin.webresource.WebResourceManagerImpl" plugin:available="true">
        <constructor-arg index="0" ref="webResourceAssemblerFactory"/>
        <constructor-arg index="1" ref="pageBuilderService"/>
        <constructor-arg index="2" ref="pluginResourceLocator"/>
        <constructor-arg index="3" ref="webResourceIntegration"/>
        <constructor-arg index="4" ref="webResourceUrlProvider"/>
        <constructor-arg index="5" ref="resourceBatchingConfiguration"/>
        <constructor-arg index="6" ref="resourceResolver"/>
        <plugin:interface>com.atlassian.plugin.webresource.WebResourceManager</plugin:interface>
    </bean>
    <bean id="webResourceUrlProvider" class="com.atlassian.plugin.webresource.WebResourceUrlProviderImpl" plugin:available="true">
        <constructor-arg ref="webResourceIntegration"/>
        <plugin:interface>com.atlassian.plugin.webresource.WebResourceUrlProvider</plugin:interface>
    </bean>

    <!-- The system DataSourceConfiguration, initialised with the settings to connect to the "normal" database. This
         is the database configured in stash-defaults.properties or stash-config.properties (for the default HSQL
         database or an external database, respectively). -->
    <bean id="dataSourceConfiguration" class="com.atlassian.stash.internal.hibernate.DefaultDataSourceConfiguration">
        <constructor-arg index="0" value="${jdbc.driver}"/>
        <constructor-arg index="1" value="${jdbc.user}"/>
        <constructor-arg index="2" value="${jdbc.password}"/>
        <constructor-arg index="3" value="${jdbc.url}"/>
        <property name="connectTimeout" value="${db.pool.connection.timeout}"/>
    </bean>

    <!-- This prototype is used to create DataSources from a DataSourceConfiguration provided to their constructor.

         When used with BeanFactory.getBean(String, Object...), the <constructor-arg/> provided here in the Spring
         wiring is _overridden_ and the DataSourceConfiguration provided is used _instead_. That allows database
         migration to get a DataSource using all of the normal pool configuration but with different data source
         configuration, connecting the pool to a new target database.

         To facilitate this, this bean is marked as a prototype, and is explicitly marked as not being a candidate
         for autowiring. If it were autowire-capable, @Autowired DataSource dataSource would fail with multiple
         candidates. It must be prototype scope so that different instances can be created using getBean(...).

         This prototype should be referenced _exactly once_ in the XML configuration, to initialise the "dataSource"
         bean with the system database. Referencing it anywhere else will result in multiple pools pointed at the
         same database. -->
    <bean id="dataSourcePrototype" class="com.atlassian.stash.internal.hibernate.ExtendedBoneCPDataSource"
          autowire-candidate="false" scope="prototype">
        <!-- The "default" configuration is an instance which is initialised from stash-defaults.properties and
             stash-config.properties, meaning it will use the database which has been configured by the user (or
             the in-memory HSQL database if one has not been configured). -->
        <constructor-arg ref="dataSourceConfiguration"/>
        <property name="acquireIncrement" value="${db.pool.acquireIncrement}"/>
        <property name="connectionHook">
            <bean class="com.atlassian.stash.internal.hibernate.CleanupConnectionHook"/>
        </property>
        <property name="connectionTimeoutInSeconds" value="${db.pool.connection.timeout}"/>
        <!-- We must set the isolation level on the data source as well as on the hibernate session factory.
            Spring transactions allow us to specify an isolation level, which by default matches the datasource's
            isolation level. When inside a spring transaction the transaction's isolation level clobbers the session's
            transaction level. For most DBs the default is 2/READ-COMMITTED but for MySQL 5.5 it is 4/REPEATABLE_READ.
        -->
        <property name="defaultTransactionIsolation" value="READ_COMMITTED"/>
        <property name="disableConnectionTracking" value="true"/>
        <property name="idleConnectionTestPeriodInMinutes" value="${db.pool.idle.testInterval}"/>
        <property name="idleMaxAgeInMinutes" value="${db.pool.idle.maxAge}"/>
        <property name="maxConnectionsPerPartition" value="${db.pool.partition.connection.maximum}"/>
        <property name="minConnectionsPerPartition" value="${db.pool.partition.connection.minimum}"/>
        <property name="partitionCount" value="${db.pool.partition.count}"/>
        <property name="poolAvailabilityThreshold" value="${db.pool.partition.connection.threshold}"/>
        <property name="statementsCacheSize" value="${db.pool.cache.statements}"/>
        <property name="releaseHelperThreads" value="${db.pool.threads}"/>
    </bean>

    <!-- Depends on "homeLockAcquirer" to ensure the home directory has been locked before constructing the DataSource
         and potentially connecting to the database. -->
    <bean id="dataSource" class="com.atlassian.stash.internal.hibernate.DelegatingSwappableDataSource"
          depends-on="homeLockAcquirer">
        <!-- Instantiates the dataSourcePrototype using the configured database. This provides an initial pool which
             is pointed to the "normal" database. Except in cases of migration, this should be the only pool that is
             ever created, and will be used for the duration of execution.

             Warning: This must be the _only_ place in the Spring configuration which uses the prototype. Everywhere
             else a DataSource is needed should be using this "dataSource" bean. -->
        <constructor-arg index="0" ref="dataSourcePrototype"/>
    </bean>

    <!-- Defines common configuration that should be applied to all Liquibase beans. This allows them to be configured
         in a single location. -->
    <bean id="liquibaseParent" abstract="true" class="liquibase.database.DefaultingSchemaLiquibase">
        <property name="changeLog" value="classpath:liquibase/master.xml"/>
        <property name="lockMaxWait" value="${db.schema.lock.maxWait}"/>
        <property name="lockPollInterval" value="${db.schema.lock.pollInterval}"/>
    </bean>
    <!-- A prototype for Liquibase bean creation. This is used during database migration and setup. The intention here
         is to reduce fragility by ensuring the wiring for the Liquibase instance used during migration and setup will
         always be the same as the wiring for the one that manages the schema during application startup. -->
    <bean id="liquibasePrototype" autowire-candidate="false" parent="liquibaseParent" scope="prototype"/>
    <!-- Depends on "databaseSupplier" to ensure the system does not attempt to create/migrate the schema when it is
         connected to an unsupported database. This bean manages the schema during application startup. -->
    <bean id="liquibase" depends-on="databaseSupplier" parent="liquibaseParent">
        <!-- Note: Do _not_ wire in the dataSourcePrototype here. It must only be used once. -->
        <constructor-arg ref="dataSource"/>
    </bean>

    <bean id="crowdAwareLoadListener" class="com.atlassian.stash.internal.hibernate.CrowdAwareLoadListener">
        <constructor-arg>
            <idref bean="crowdService"/>
        </constructor-arg>
    </bean>

    <!-- This prototype is used to create SessionFactoryBeans from a DataSource provided to their constructor. Spring
         SessionFactoryBeans are all singleton beans, meaning each one will create exactly one SessionFactory and will
         return that same instance on all subsequent uses. The entire SessionFactoryBean is treated as a prototype to
         allow, by extension, creating multiple SessionFactory instances.

         When used with BeanFactory.getBean(String, Object...), the <constructor-arg/> provided here in the Spring
         wiring is _overridden_ and the DataSource provided is used _instead_. That allows database migration to get
         a SessionFactory using all of the normal Hibernate configuration but with different data source, connecting
         Hibernate to a new target database.

         To facilitate this, this bean is marked as a prototype, and is explicitly marked as not being a candidate
         for autowiring. If it were autowire-capable, @Autowired SessionFactory sessionFactory would fail with multiple
         candidates. It must be prototype scope so that different instances can be created using getBean(...).

         This prototype should be referenced _exactly once_ in the XML configuration, to initialise the "sessionFactory"
         bean with a Hibernate SessionFactory connected to the system database. Referencing it anywhere else will result
         in multiple session factories pointed at the same database. -->
    <bean id="sessionFactoryPrototype" class="com.atlassian.stash.internal.hibernate.ExtendedLocalSessionFactoryBean"
          autowire-candidate="false" scope="prototype">
        <!-- Note: Do _not_ wire in the dataSourcePrototype here. It must only be used once. -->
        <constructor-arg ref="dataSource"/>
        <property name="configLocation" value="classpath:com/atlassian/crowd/hibernate-crowd.xml"/>
        <property name="packagesToScan">
            <list>
                <value>com.atlassian.stash.internal</value>
            </list>
        </property>
        <property name="eventListeners">
            <map key-type="org.hibernate.event.spi.EventType">
                <entry key="#{T(org.hibernate.event.spi.EventType).LOAD}" value-ref="crowdAwareLoadListener"/>
                <entry key="#{T(org.hibernate.event.spi.EventType).MERGE}">
                    <bean class="com.atlassian.hibernate.extras.event.IdTransferringMergeEventListener"/>
                </entry>
                <entry key="#{T(org.hibernate.event.spi.EventType).POST_LOAD}" value-ref="crowdAwareLoadListener"/>
            </map>
        </property>
        <property name="entityInterceptor">
            <bean class="com.atlassian.stash.internal.hibernate.NoEmptyStringsInterceptor"/>
        </property>
        <property name="hibernateProperties">
            <props>
                <prop key="hibernate.bytecode.use_reflection_optimizer">true</prop>
                <prop key="hibernate.cache.region.factory_class">
                    org.hibernate.cache.ehcache.SingletonEhCacheRegionFactory
                </prop>
                <prop key="hibernate.cache.use_query_cache">true</prop>
                <prop key="hibernate.cache.use_second_level_cache">true</prop>
                <prop key="hibernate.connection.autocommit">false</prop>
                <prop key="hibernate.connection.isolation">2</prop>
                <prop key="hibernate.discriminator.ignore_explicit_for_joined">true</prop>
                <prop key="hibernate.id.new_generator_mappings">true</prop>
                <prop key="hibernate.current_session_context_class">
                    org.springframework.orm.hibernate4.SpringSessionContext
                </prop>
                <prop key="hibernate.format_sql">${hibernate.format_sql}</prop>
                <prop key="hibernate.generate_statistics">false</prop>
                <prop key="hibernate.hbm2ddl.auto">validate</prop>
                <prop key="hibernate.jdbc.batch_size">${hibernate.jdbc.batch_size}</prop>
                <prop key="hibernate.show_sql">${hibernate.show_sql}</prop>
            </props>
        </property>
        <property name="validatorFactory" ref="validator"/>
    </bean>

    <!-- Depends on "ehcache" to ensure init and destroy methods are called in the correct order. SessionFactory tries
         to remove the caches one by one when it's shutting down. If EhCacheManagerFactoryBean has destroyed the
         CacheManager before that, many (DEBUG) messages will be generated.
         Depends on "liquibase" to ensure the database schema has been created/updated before Hibernate attempts to
         validate it (as a normal part of starting the SessionFactory). -->
    <bean id="sessionFactory" class="com.atlassian.stash.internal.hibernate.DelegatingSwappableSessionFactory"
          depends-on="ehcache,liquibase">
        <!-- Instantiates the sessionFactoryPrototype using the configured database. This provides an initial session
             factory which is pointed to the "normal" database. Except in cases of migration, this should be the only
             session factory that is ever created, and will be used for the duration of execution.

             Warning: This must be the _only_ place in the Spring configuration which uses the prototype. Everywhere
             else a SessionFactory is needed should be using this "sessionFactory" bean. -->
        <constructor-arg index="0" ref="sessionFactoryPrototype"/>
    </bean>

    <bean id="dataSourceProvider" class="com.atlassian.stash.internal.ao.ApplicationDataSourceProvider"
          plugin:available="true">
        <plugin:interface>com.atlassian.activeobjects.spi.DataSourceProvider</plugin:interface>
        <constructor-arg index="0">
            <!-- Inject the ActiveObjects DataSourceProvider with a TransactionAware DataSource. This means that, when
                 ActiveObjects requests a connection from its data source, if there is a transaction going on, it will
                 get the connection allocated to the transaction, rather than a new connection. Otherwise, if there is
                 no transaction, it will get a connection from the underlying data source. -->
            <bean class="com.atlassian.stash.internal.spring.TransactionAwareDataSource">
                <!-- Note: Do _not_ wire in the dataSourcePrototype here. It must only be used once. -->
                <constructor-arg ref="dataSource"/>
            </bean>
        </constructor-arg>
        <constructor-arg index="1" ref="dataSourceConfiguration"/>
    </bean>

    <bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager">
        <!-- Note: Do _not_ wire in the dataSourcePrototype here. It must only be used once. -->
        <property name="dataSource" ref="dataSource"/>
        <!-- Note: Do _not_ wire in the sessionFactoryPrototype here. It must only be used once. -->
        <property name="sessionFactory" ref="sessionFactory"/>
    </bean>

    <bean id="scheduledExecutorService" class="com.atlassian.stash.internal.concurrent.StateTransferringScheduledExecutorService"
          destroy-method="shutdownNow" plugin:available="true">
        <plugin:interface>java.util.concurrent.ScheduledExecutorService</plugin:interface>
        <plugin:interface>java.util.concurrent.ExecutorService</plugin:interface>
        <plugin:interface>java.util.concurrent.Executor</plugin:interface>
        <constructor-arg>
            <bean class="com.atlassian.stash.internal.concurrent.ConfigurableScheduledExecutorService">
                <constructor-arg index="0" value="${executor.max.threads}"/>
                <constructor-arg index="1">
                    <bean class="com.atlassian.util.concurrent.ThreadFactories" factory-method="namedThreadFactory">
                        <constructor-arg value="threadpool"/>
                        <constructor-arg value="DAEMON"/>
                    </bean>
                </constructor-arg>
                <property name="keepAliveTimeSeconds" value="${executor.keepAliveTime}"/>
                <property name="allowCoreThreadTimeOut" value="true"/>
            </bean>
        </constructor-arg>
    </bean>

    <bean id="changesetIndexingScheduler" class="com.atlassian.stash.internal.idx.ChangesetIndexingScheduler">
        <constructor-arg index="0" ref="changesetIndexingService"/>
        <constructor-arg index="1" ref="repositoryService"/>
        <constructor-arg index="2" ref="securityService"/>
        <constructor-arg index="3">
            <bean class="java.util.concurrent.ThreadPoolExecutor" destroy-method="shutdownNow">
                <constructor-arg index="0" value="#{T(java.lang.Math).min(2, ${indexing.max.threads})}"/>
                <constructor-arg index="1" value="${indexing.max.threads}"/>
                <constructor-arg index="2" value="5"/>
                <constructor-arg index="3" value="MINUTES"/>
                <constructor-arg index="4">
                    <bean class="java.util.concurrent.LinkedBlockingQueue">
                        <constructor-arg index="0" value="${indexing.job.queue.size}"/>
                    </bean>
                </constructor-arg>
                <constructor-arg index="5">
                    <bean class="com.atlassian.util.concurrent.ThreadFactories" factory-method="namedThreadFactory">
                        <constructor-arg value="Indexer"/>
                        <constructor-arg value="DAEMON"/>
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
    </bean>

    <bean id="externalProcessFactory"  class="com.atlassian.stash.internal.process.ConfigurableExternalProcessFactory">
        <constructor-arg index="0">
            <bean class="com.atlassian.stash.internal.concurrent.StateTransferringExecutorService"
                  destroy-method="shutdownNow">
                <constructor-arg>
                    <bean class="java.util.concurrent.ThreadPoolExecutor">
                        <constructor-arg index="0" value="9"/>
                        <constructor-arg index="1" value="1500"/>
                        <constructor-arg index="2" value="2"/>
                        <constructor-arg index="3" value="MINUTES"/>
                        <constructor-arg index="4">
                            <bean class="java.util.concurrent.SynchronousQueue"/>
                        </constructor-arg>
                        <constructor-arg index="5">
                            <bean class="com.atlassian.util.concurrent.ThreadFactories" factory-method="namedThreadFactory">
                                <constructor-arg value="ExtProcess - IO Pump"/>
                                <constructor-arg value="DAEMON"/>
                            </bean>
                        </constructor-arg>
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <constructor-arg index="1" ref="applicationSettings"/>
    </bean>

    <bean id="mailLogger" class="com.atlassian.stash.internal.mail.DefaultMailLogger">
        <constructor-arg index="0" value="${mail.error.pause.log}"/>
    </bean>

    <bean id="mailService" class="com.atlassian.stash.internal.mail.MailServiceImpl" plugin:available="true" init-method="initMailSender" destroy-method="shutdown">
        <plugin:interface>com.atlassian.stash.mail.MailService</plugin:interface>
        <constructor-arg index="0" ref="applicationPropertiesService"/>
        <constructor-arg index="1" ref="i18nService"/>
        <constructor-arg index="2" ref="javaMailSenderFactory"/>
        <constructor-arg index="3">
            <bean class="com.atlassian.stash.internal.concurrent.PauseableStateTransferringExecutorService">
                <constructor-arg>
                    <bean class="com.atlassian.stash.internal.concurrent.PauseableThreadPoolExecutor">
                        <constructor-arg index="0" value="1"/>
                        <constructor-arg index="1" value="${mail.threads}"/>
                        <constructor-arg index="2" value="2"/>
                        <constructor-arg index="3" value="MINUTES"/>
                        <constructor-arg index="4">
                            <bean class="java.util.concurrent.LinkedBlockingDeque"/>
                        </constructor-arg>
                        <constructor-arg index="5">
                            <bean class="com.atlassian.util.concurrent.ThreadFactories" factory-method="namedThreadFactory">
                                <constructor-arg value="MailServiceSender"/>
                                <constructor-arg value="DAEMON"/>
                            </bean>
                        </constructor-arg>
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <constructor-arg index="4" ref="mailQueueGuard"/>
        <constructor-arg index="5" ref="mailLogger"/>
        <constructor-arg index="6" value="${mail.error.pause.retry}"/>
        <constructor-arg index="7" value="${mail.max.message.size}"/>
    </bean>

    <bean id="mailQueueGuard" class="com.atlassian.stash.internal.mail.DefaultMailQueueSizeGuard">
        <constructor-arg index="0" value="${mail.max.queue.size}"/>
        <constructor-arg index="1" ref="mailLogger"/>
    </bean>

    <bean class="com.atlassian.stash.internal.pull.comment.drift.DriftCommentUpdateProcessor">
        <constructor-arg index="0" ref="driftRequestDao"/>
        <constructor-arg index="1">
            <bean class="com.atlassian.stash.internal.concurrent.StateTransferringExecutorService"
                  destroy-method="shutdownNow">
                <constructor-arg>
                    <bean class="java.util.concurrent.Executors" factory-method="newFixedThreadPool">
                        <constructor-arg value="${pullrequest.rescope.drift.threads}"/>
                        <constructor-arg>
                            <bean class="com.atlassian.util.concurrent.ThreadFactories" factory-method="namedThreadFactory">
                                <constructor-arg value="drift"/>
                                <constructor-arg value="DAEMON"/>
                            </bean>
                        </constructor-arg>
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <constructor-arg index="2" ref="lockService"/>
        <constructor-arg index="3" ref="scmService"/>
        <constructor-arg index="4" ref="securityService"/>
        <constructor-arg index="5">
            <list value-type="com.atlassian.stash.internal.pull.comment.drift.CommentDriftStrategy">
                <bean class="com.atlassian.stash.internal.pull.comment.drift.FileCommentDriftStrategy">
                    <constructor-arg index="0" ref="scmService"/>
                </bean>
                <bean class="com.atlassian.stash.internal.pull.comment.drift.FastForwardCommentDriftStrategy">
                    <constructor-arg index="0" ref="scmService"/>
                </bean>
                <bean class="com.atlassian.stash.internal.pull.comment.drift.DiffCommentDriftStrategy">
                    <constructor-arg index="0" ref="scmService"/>
                </bean>
                <bean class="com.atlassian.stash.internal.pull.comment.drift.OrphanAllCommentDriftStrategy"/>
            </list>
        </constructor-arg>
        <constructor-arg index="6" ref="transactionManager"/>
    </bean>

    <bean class="com.atlassian.stash.internal.pull.rescope.DefaultRescopeProcessor">
        <constructor-arg index="0" ref="pullRequestActivityDao"/>
        <constructor-arg index="1" ref="pullRequestRescopeActivityDetailsProvider"/>
        <constructor-arg index="2">
            <bean class="com.atlassian.stash.internal.concurrent.StateTransferringExecutorService"
                  destroy-method="shutdownNow">
                <constructor-arg>
                    <bean class="java.util.concurrent.Executors" factory-method="newFixedThreadPool">
                        <constructor-arg value="${pullrequest.rescope.detail.threads}"/>
                        <constructor-arg>
                            <bean class="com.atlassian.util.concurrent.ThreadFactories" factory-method="namedThreadFactory">
                                <constructor-arg value="rescope-details"/>
                                <constructor-arg value="DAEMON"/>
                            </bean>
                        </constructor-arg>
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <constructor-arg index="3" ref="transactionSynchronizer"/>
        <constructor-arg index="4">
            <bean class="org.springframework.transaction.support.TransactionTemplate">
                <constructor-arg index="0" ref="transactionManager"/>
                <property name="propagationBehaviorName" value="PROPAGATION_REQUIRES_NEW"/>
            </bean>
        </constructor-arg>
    </bean>

    <bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean" plugin:available="true">
        <property name="validationMessageSource" ref="messageSource"/>
        <property name="constraintValidatorFactory" ref="constraintValidatorFactory"/>
        <plugin:interface>javax.validation.Validator</plugin:interface>
    </bean>

    <bean id="stashDownloadPolicyProvider" class="com.atlassian.stash.internal.web.http.download.StashDownloadPolicyProvider">
        <constructor-arg index="0" value="${http.download.raw.policy}"/>
    </bean>
    <bean id="hostileExtensionDetector" class="com.atlassian.http.mime.HostileExtensionDetector"/>
    <bean id="contentDispositionHeaderGuesser" class="com.atlassian.http.mime.ContentDispositionHeaderGuesser">
        <constructor-arg ref="stashDownloadPolicyProvider"/>
        <constructor-arg ref="hostileExtensionDetector"/>
    </bean>

    <bean id="helpPathProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
        <property name="ignoreResourceNotFound" value="true"/>
        <property name="locations">
            <list>
                <value>classpath:help-paths.properties</value>
                <!-- This will only get picked up if it exists and ignored if it doesn't -->
                <!--suppress SpringModelInspection -->
                <value>classpath:help-paths-hosted.properties</value>
                <value>file:${stash.home}/help-paths.properties</value>
            </list>
        </property>
    </bean>

    <bean id="dateFormatProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
        <property name="ignoreResourceNotFound" value="true"/>
        <property name="locations">
            <list>
                <value>classpath:date-formats.properties</value>
                <value>file:${stash.home}/date-formats.properties</value>
            </list>
        </property>
    </bean>

    <bean id="md5Encoder" class="org.springframework.security.authentication.encoding.MessageDigestPasswordEncoder">
        <constructor-arg value="MD5"/>
    </bean>
    <bean id="shaEncoder" class="org.springframework.security.authentication.encoding.MessageDigestPasswordEncoder">
        <constructor-arg value="SHA-1"/>
    </bean>

    <bean id="secureTokenGenerator" class="com.atlassian.security.random.DefaultSecureTokenGenerator" factory-method="getInstance"/>

    <!--
    DefaultManageableImageCaptchaService is expensive to initialize.
    Delay initialization until first invocation of the service
    -->
    <bean id="imageCaptchaService" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="targetSource">
            <bean class="org.springframework.aop.target.LazyInitTargetSource">
               <property name="targetBeanName">
                   <idref bean="imageCaptchaServicePrototype"/>
               </property>
                <property name="targetClass" value="com.octo.captcha.service.image.ImageCaptchaService"/>
             </bean>
        </property>
        <property name="proxyInterfaces">
            <array>
                <value>com.octo.captcha.service.image.ImageCaptchaService</value>
            </array>
        </property>
    </bean>

    <bean id="imageCaptchaServicePrototype" class="com.octo.captcha.service.image.DefaultManageableImageCaptchaService" scope="prototype" autowire-candidate="false">
        <constructor-arg index="0">
            <bean class="com.octo.captcha.service.captchastore.FastHashMapCaptchaStore"/>
        </constructor-arg>
        <constructor-arg index="1">
            <bean class="com.atlassian.stash.internal.web.util.captcha.StashCaptchaEngine"/>
        </constructor-arg>
        <constructor-arg index="2" value="180"/>    <!--min guaranted storage delay in seconds-->
        <constructor-arg index="3" value="100000"/> <!-- max captcha store size -->
        <constructor-arg index="4" value="75000"/>  <!-- captcha store load before garbage collection -->
    </bean>
</beans>
